
@inproceedings{stuker2025jasmaint,
  abstract  = {Modern web applications integrate JavaScript code with more efficient languages compiling to WebAssembly, such as C, C++ or Rust. However, such multi-language applications challenge program understanding and increase the risk of security attacks. Dynamic taint analysis is a powerful technique used to uncover confidentiality and integrity vulnerabilities. The state of the art has mainly considered taint analysis targeting a single programming language, extended with a limited set of native extensions. To deal with data flows between the language and native extensions, taint signatures or models of those extensions have been employed. However, this does not scale for multi-language web applications as the Wasm modules evolve continuously and generally do not include their source code. This paper proposes JASMaint, the first taint analysis approach for multi-language web applications. A novel analysis orchestrator component manages the exchange of taint information during interoperation between our language-specific taint analyses. JASMaint is based on source code instrumentation for both the JavaScript and WebAssembly codebases. This choice enables deployment to all runtimes that support JavaScript and WebAssembly. We evaluate our approach on a benchmark suite of multi-language programs. Our evaluation shows that JASMaint reduces overtainting by 0.003\% - 56.20\% compared to a state-of-the-art approach for taint analysis based on function models. However, this comes at the cost of an increase in performance overhead by a factor of 1.14x - 1.61x relative to state of the art.},
  author    = {Abel Stuker and Aäron Munsters and {Luis Scull Pupo}, Angel and Laurent Christophe and {Gonzalez Boix}, Elisa},
  booktitle = {Proceedings of the 22nd International Conference on Managed Programming Languages and Runtimes (MPLR)},
  day       = {12},
  language  = {English},
  month     = oct,
  note      = {Belgium-Netherlands Software Evolution Workshop 2024, Benevol 2024 ; Conference date: 21-11-2024 Through 22-11-2024},
  publisher = {ACM},
  title     = {JASMaint: Portable Multi-language Taint Analysis for the Web},
  url       = {https://conf.researchr.org/home/icfp-splash-2025/mplr-2025},
  year      = {2025},
}


@inproceedings{laurent2024aran,
  abstract  = {We introduce Aran, a novel approach for developing heavyweight dynamic analyses of JavaScript programs. Our approach is broadly applicable, relying solely on source code instrumentation. It also supports complex customization through an intuitive aspect-oriented API, which consists of 31 entry points. With about 300 lines of code, our API can express an analysis that computes the symbolic execution tree of run-time values. Importantly, our approach preserves the semantics of the program under analysis. We implemented this approach in a tool and validated it using Test262, the official JavaScript conformance test suite, achieving a 99.7\% success rate and observing performance slowdowns rarely exceeding 10x.},
  author    = {Laurent Christophe and {De Roover}, Coen and {De Meuter}, Wolfgang},
  booktitle = {Proceedings of the 23nd Belgium-Netherlands Software Evolution Workshop (BENEVOL)},
  day       = {21},
  issn      = {1613-0073},
  language  = {English},
  month     = nov,
  note      = {Belgium-Netherlands Software Evolution Workshop 2024, Benevol 2024 ; Conference date: 21-11-2024 Through 22-11-2024},
  pages     = {97--114},
  publisher = {CEUR Workshop Proceedings},
  title     = {Aran: JavaScript Instrumentation for Heavyweight Dynamic Analysis},
  url       = {https://benevol2024.github.io},
  volume    = {3941},
  year      = {2024},
}

@article{maarten2020prioritising,
  abstract = {Context: Most approaches to automated white-box testing consider the client side and the server side of a web application in isolation from each other. Such testers lack a whole-program perspective on the web application under test.Inquiry: We hypothesise that an additional whole-program perspective would enable the tester to discover which server side errors can be triggered by an actual end user accessing the application through the client, and which ones can only be triggered in hypothetical scenarios.Approach: In this paper, we explore the idea of employing such a whole-program perspective in inter-process testing. To this end, we develop StackFul, a novel concolic tester which operates on full-stack JavaScript web applications, where both the client and the server side are JavaScript processes communicating via asyn- chronous messages —as enabled by e.g., the WebSocket or Socket.IO-libraries.Knowledge: We find that the whole-program perspective enables discerning high-priority errors, which are reachable from a particular client, from low-priority errors, which are not accessible through the tested client. Another benefit of the perspective is that it allows the automated tester to construct practical, step-by- step scenarios for triggering server side errors from the end user{\textquoteright}s perspective.Grounding: We apply StackFul on a collection of web applications to evaluate how effective inter- process testing is in distinguishing between high- and low-priority errors. The results show that StackFul correctly classifies the majority of server errors.Importance: This paper demonstrates the feasibility of inter-process testing as a novel approach for au- tomatically testing web applications. Classifying errors as being of high or low importance aids developers in prioritising bugs that might be encountered by users, and postponing the diagnosis of bugs that are less easily reached.},
  author   = {Maarten Vandercammen and Laurent Christophe and {Di Nucci}, Dario and {De Meuter}, Wolfgang and {De Roover}, Coen},
  day      = {1},
  doi      = {10.22152/programming-journal.org/2021/5/5},
  issn     = {2473-7321},
  journal  = {The Art, Science, and Engineering of Programming},
  keywords = {Concolic Testing, Whitebox Testing, Full-stack Applications, concolic testing, web applications, automated testing},
  language = {English},
  month    = oct,
  number   = {2},
  title    = {Prioritising Server Side Reachability via Inter-process Concolic Testing},
  volume   = {5},
  year     = {2020},
}

@inproceedings{maarten2018concolic,
  abstract  = {Recent years have seen the rise of so-called full-stack JavaScript web applications, where both the client and the server side of the web application are developed in JavaScript. Both sides communicate with each other via asynchronous messages, as enabled by e.g., WebSockets. Traditionally, automated whitebox testing of web applications involves testing both sides of the application in isolation from each other. However, this approach lacks a holistic overview of the entire web application under test. This leads to inaccuracies in the types of program bugs that are reported by the tester, and makes it more difficult for developers to understand how the behaviour of the client may affect the behaviour of the server, and vice versa. An interesting side-effect of the evolution towards full-stack applications is that a single automated tester can be developed that observes the execution of both parts of the system simultaneously, thereby remedying the aforementioned issues. In this paper, we examine the benefits and design challenges in employing such a holistic approach towards testing full-stack applications, and we demonstrate STACKFUL, the first concolic tester for full-stack JavaScript applications.},
  author    = {Maarten Vandercammen and Laurent Christophe and {De Meuter}, Wolfgang and {De Roover}, Coen},
  booktitle = {Proceedings of the 17th Belgium-Netherlands Software Evolution Workshop (BENEVOL)},
  day       = {11},
  language  = {English},
  month     = dec,
  note      = {Belgium-Netherlands Software Evolution Workshop 2018, Benevol 2018 ; Conference date: 10-12-2018 Through 11-12-2018},
  number    = {7},
  pages     = {38--42},
  publisher = {CEUR Workshop Proceedings},
  series    = {Proceedings of the 17th Belgium-Netherlands Software Evolution Workshop},
  title     = {Concolic Testing of Full-Stack JavaScript Applications},
  url       = {https://se.ewi.tudelft.nl/benevol2018/, http://se.ewi.tudelft.nl/benevol2018/},
  volume    = {2361},
  year      = {2018},
}

@inproceedings{laurent2018orchestrating,
  abstract  = {Dynamic analyses are commonly implemented by instrumenting the program under analysis.Examples of such analyses for JavaScript range from checkers of user-defined invariants to concolic testers.For a full-stack JavaScript program, these analyses need to reason about the state of the client-side and server-side processes it is comprised of.Lifting a dynamic analysis so that it supports full-stack programs can be challenging. It involves distributed communication to maintain the analysis state across all processes, which has to be deadlock-free.In this paper, we advocate maintaining distributed analysis state in a centralized analysis process instead ---which is communicated with from the processes under analysis. The approach is supported by a dynamic analysis platform that provides abstractions for this communication.We evaluate the approach through a case study.We use the platform to build a distributed origin analysis, capable of tracking the expressions from which values originate from across process boundaries, and deploy it on collaborative drawing application. The results show that our approach greatly simplifies the lifting process at the cost of a computational overhead.We deem this overhead acceptable for analyses intended for use at development time.},
  author    = {Laurent Christophe and {De Roover}, Coen and {Gonzalez Boix}, Elisa and {De Meuter}, Wolfgang},
  booktitle = {Proceedings of the 17th ACM SIGPLAN International Conference on Generative Programming (GPCE)},
  day       = {5},
  doi       = {10.1145/3278122.3278135},
  editor    = {{Van Wyk}, Eric and Tiark Rompf},
  isbn      = {978-1-4503-6045-6},
  keywords  = {Distributed Applications, Dynamic Analysis, JavaScript},
  language  = {English},
  month     = nov,
  note      = {International Conference on Generative Programming: Concepts \& Experience, GPCE ; Conference date: 05-11-2018 Through 06-11-2018},
  pages     = {107--118},
  publisher = {ACM},
  title     = {Orchestrating Dynamic Analyses of Distributed Processes for Full-Stack JavaScript Programs},
  year      = {2018},
}

@inproceedings{scull2018practical,
  abstract  = {Current browser-level security solutions do not provide a mechanism for information flow control (IFC) policies. As such, they need to be combined with language-based security approaches. Practical implementations for ICF enforcement remains a challenge when the full spectrum of web applications features is taken into account (i.e. JavaScript features, web APIs, DOM, portability, performance, etc.). In this work we develop Gifc, a permissive-upgrade-based inlined monitoring mechanism to detect unwanted information flow in web applications. Gifc covers a wide range of JavaScript features that give rise to implicit flows. In contrast to related work, Gifc also handles dynamic code evaluation online, and it features an API function model mechanism that enables information tracking through APIs calls. As a result, Gifc can handle information flows that use DOM nodes as channels of information. We validate Gifc by means of a benchmark suite from literature specifically designed for information flow verification, which we also extend. We compare Gifc qualitatively with respect to closest related work and show that Gifc performs better at detecting unwanted implicit flows.},
  author    = {{Scull Pupo}, {Angel Luis} and Laurent Christophe and Jens Nicolay and {De Roover}, Coen and {Gonzalez Boix}, Elisa},
  booktitle = {Proceedings of the 18th International Conference on Runtime Verification (RV)},
  doi       = {10.1007/978-3-030-03769-7_21},
  isbn      = {978-3-030-03768-0},
  keywords  = {Security, JavaScript, Web Applications},
  language  = {English},
  month     = nov,
  note      = {18th International Conference on Runtime Verification, RV ; Conference date: 11-11-2018 Through 13-11-2018},
  pages     = {372--388},
  publisher = {Springer},
  title     = {Practical Information Flow Control for Web Applications},
  volume    = {11237},
  year      = {2018},
}

@inproceedings{laurent2016linvail,
  abstract  = {We present Linvail, a novel instrumentation platform for developing dynamic analyses of JavaScript programs. Linvail is particularly well-suited to implementing shadow executions which involve tagging runtime values with analysis-specific data. In contrast to existing instrumentation platforms, Linvail is capable of tracking both tagged objects and tagged primitive values during their entire life-time in a behavior-preserving manner. To demonstrate the expressiveness of our platform, we present the implementation of several state-of-the-art analyses. Our experiments demonstrate that Linvail{\textquoteright}s accuracy comes at the price of a performance overhead, but we believe that real-world applications will remain usable under analysis.},
  author    = {Laurent Christophe and {De Meuter}, Wolfgang and {Gonzalez Boix}, Elisa and {De Roover}, Coen},
  booktitle = {Proceedings of the 23rd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER)},
  day       = {18},
  isbn      = {978-1-5090-1855-0},
  keywords  = {Shadow Execution, Dynamic Analysis, JavaScript, Taint Analysis, Object Proxy, Reflection, Membrane Pattern, ECMAScript6},
  language  = {English},
  month     = mar,
  note      = {23rd IEEE International Conference on Software Analysis, Evolution, and Reengineering (SANER2016) ; Conference date: 14-03-2016 Through 18-03-2016},
  pages     = {260--270},
  publisher = {IEEE CS},
  title     = {Linvail: A General-Purpose Platform for Shadow Execution of JavaScript},
  year      = {2016},
}

@inproceedings{laurent2015poster,
  abstract  = {JavaScript has become a popular programming language. However, its highly dynamic nature encumbers static analysis for quality assurance purposes. Only dynamic techniques such as concolic testing seem to cope. Often, these involve an instrumentation phase in which source code is extended with analysis-specific concerns. The corresponding implementations represent a duplication of engineering efforts. To facilitate developing dynamic analyses for JavaScript, we introduce Aran; a general-purpose JavaScript instrumenter that takes advantage of proxies, a recent addition to the JavaScript reflection APIs.},
  author    = {Laurent Christophe and {De Roover}, Coen and {De Meuter}, Wolfgang},
  booktitle = {Proceedings of the 37th IEEE International Conference on Software Engineering (ICSE)},
  day       = {16},
  isbn      = {978-1-4799-1934-5},
  keywords  = {dynamic analysis, JavaScript, program instrumentation},
  language  = {English},
  month     = may,
  note      = {the 37th IEEE International Conference on Software Engineering (ICSE 2015) ; Conference date: 16-05-2015 Through 24-05-2015},
  pages     = {813--814},
  publisher = {IEEE},
  title     = {Poster: Dynamic Analysis Using JavaScript Proxies},
  volume    = {2},
  year      = {2015},
}


@inproceedings{laurent2014prevalence,
  abstract  = {Functional testing requires executing particular sequences of user actions. Test automation tools enable scripting user actions such that they can be repeated more easily. SELENIUM, for instance, enables testing web applications through scripts that interact with a web browser and assert properties about its observable state. However, little is known about how common such tests are in practice. We therefore present a cross-sectional quantitative study of the prevalence of SELENIUM-based tests among open-source web applications, and of the extent to which such tests are used within individual applications. Automating functional tests also brings about the problem of maintaining test scripts. As the system under test evolves, its test scripts are bound to break. Even less is known about the way test scripts change over time. We therefore also present a longitudinal quantitative study of whether and for how long test scripts are maintained, as well as a longitudinal qualitative study of the kind of changes they undergo. To the former's end, we propose two new metrics based on whether a commit to the application's version repository touches a test file. To the latter's end, we propose to categorize the changes within each commit based on the elements of the test upon which they operate. As such, we are able to identify the elements of a test that are most prone to change.},
  author    = {Laurent Christophe and Reinout Stevens and {De Roover}, Coen and {De Meuter}, Wolfgang},
  booktitle = {Proceedings of the 30th International Conference on Software Maintenance and Evolution (ICSME)},
  day       = {1},
  isbn      = {978-1-4799-6146-7},
  keywords  = {Functional Testing, Selenium, Test Maintenance, empirical study, mining software repositories},
  language  = {English},
  month     = oct,
  note      = {IEEE International Conference on Software Maintenance and Evolution (ICSME 2014) ; Conference date: 28-09-2014 Through 03-10-2014},
  pages     = {141--150},
  series    = {Proceedings of the 30th International Conference on Software Maintenance and Evolution (ICSMe14)},
  title     = {Prevalence and Maintenance of Automated Functional Tests for Web Applications},
  year      = {2014},
}

@inproceedings{nicolas2014runtime,
  abstract  = {Context-oriented programming enables the composition of behavioral adaptations into a running software system. Behavioral adaptations provide the most appropriate behavior of a system when their contexts are activated or deactivated, according to the situations at hand in the system's execution environment. Behavioral adaptations can be defined by third-party vendors or even be acquired at run time. As the systems grows in complexity it becomes increasingly difficult to reason about every possible runtime adaptation. Therefore, behavioral adaptations that lead to erroneous states or compromise the system's security might be difficult to detect statically. To prevent such undesired behavioral adaptations from happening, we introduce a run-time correctness verification approach. Our approach uses a symbolic execution engine to reason about the reachable states of the system, whenever contexts are activated or deactivated. Context activation and deactivation requests are allowed depending on the presence of erroneous states within reachable states. Our approach is a step forward to ensure the run-time correctness of software systems that adapt their behavior dynamically.},
  author    = {{Cardozo Alvarez}, Nicolas and Laurent Christophe and {De Roover}, Coen and {De Meuter}, Wolfgang},
  booktitle = {Proceedings of 6th International Workshop on Context-Oriented Programming (COP)},
  doi       = {10.1145/2637066.2637071},
  isbn      = {978-1-4503-2861-6},
  keywords  = {context-oriented programming, symbolic execution, program validation, run-time adaptation},
  language  = {English},
  note      = {6th International Workshop on Context-Oriented Programming ; Conference date: 29-07-2014 Through 29-07-2014},
  publisher = {ACM},
  title     = {Run-time Validation of Behavioral Adaptations},
  year      = {2014},
}