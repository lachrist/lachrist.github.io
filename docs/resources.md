---
layout: page
title: Resources
---

In no particular order, a collection of resources that I recommend.

- [Category Theory - Bartosz Milewski](https://youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_) I’m currently exploring category theory, not as a “key to the universe,” but as a pragmatic tool to identify and apply useful abstractions in software design.
- [Simple Made Easy - Rich Hickey](https://www.infoq.com/presentations/Simple-Made-Easy/) What stuck with me from this talk is the reassurance that simplicity does not necessarily equate to conciseness. The length of a specification should be low on the list of concerns when designing a maintainable system. This resonates with me because when I compile JavaScript code to AranLang, the result is simpler to analyze, even though it becomes considerably longer.
- [Structure and Interpretation of Computer Programs](https://web.mit.edu/6.001/6.037/sicp.pdf) This classic sparked my love for the implementation of programming languages. It offers a deep understanding of core concepts in managed languages, including: closures, recursion, streams, and continuations.
- [Functional Architecture - The Pits of Success - Mark Seemann](https://www.youtube.com/watch?v=US8QG9I1XW0) If you are an experienced OOP programmer, this talk provides a clear introduction to the benefits of functional programming. The main takeaway is that composition requires separating behavior from data; the exact opposite of what OOP advocates.
- [The Functional Programmer's Toolkit - Scott Wlaschin](https://www.youtube.com/watch?v=Nrp_LZ-XGsY) This talk is a great introduction to functional programming and how it enables clean composition.
- [Solving Problems the Clojure Way - Rafal Dittwald](https://www.youtube.com/watch?v=vK1DazRK_a0) I firmly believe that state management is the bedrock of software design. Consequently, I spend a significant portion of my day designing mutations to make systems easier to reason about and maintain. This talk provides a compelling perspective on state management for GUIs, which is notoriously difficult to get right.
